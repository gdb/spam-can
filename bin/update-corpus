#!/usr/bin/env ruby
require 'logger'
require 'optparse'
require 'rubygems'
require 'net/imap'

require File.join(File.dirname(__FILE__), '../lib/spam-can')
require 'iconv'

$log = Logger.new(STDOUT)
$log.level = Logger::WARN

module SpamCan
  class UpdateCorpus
    include CLIHelper
    attr_accessor :conn

    DEFAULT_MAX = 2000

    def initialize(hostname, username, password)
      @hostname = hostname
      @username = username
      @password = password
      connect
    end

    def connect
      log_announce("Connecting to #{@hostname}")
      conn = Net::IMAP.new(@hostname, 993, true)
      log_announce("Logging in as #{@username}")
      conn.login(@username, @password)
      conn
    end

    def run
      testing_set_size = 100

      t1 = Thread.new {
        conn = connect
        conn.select('[Gmail]/Spam')
        fetch_as_type(conn, 'spam', testing_set_size)
      }

      t2 = Thread.new {
        conn = connect
        conn.select('[Gmail]/Spam')
        fetch_as_type(conn, 'testing_spam', 0, testing_set_size)
      }

      t3 = Thread.new {
        conn = connect
        conn.select('[Gmail]/All Mail')
        fetch_as_type(conn, 'good', testing_set_size)
      }

      t4 = Thread.new {
        conn = connect
        conn.select('[Gmail]/All Mail')
        fetch_as_type(conn, 'testing_good', 0, testing_set_size)
      }

      [t1, t2, t3].each { |t| t.join }
    end

    def fetch_as_type(conn, type, offset=0, max=DEFAULT_MAX)
      log_announce("Going to download #{offset}-#{offset + max}/#{email_count(conn)} #{type} emails")
      fetched = email_fetch(conn, offset, max)
      log_announce("Going to save the #{fetched.length} fetched #{type} emails")
      fetched.each do |body|
        body = sanitize_utf8(body)
        model = Model::TrainingEmail.new('body' => binary(body),
                                         'type' => type,
                                         'trained' => false)
        model.save
      end
    end

    def sanitize_utf8(str)
      return nil if str.nil?
      # Per http://po-ru.com/diary/fixing-invalid-utf-8-in-ruby-revisited/
      # iconv will break if given an invalid trailing byte.  Without this
      # space hack, sanitizing e.g. "\378" will fail
      safe_str = str + ' '
      sanitized = Iconv.conv('UTF-8//IGNORE', 'UTF-8', safe_str)
      sanitized[0...-1]
    end

    def email_count(conn)
      conn.responses['EXISTS'][-1]
    end

    def email_fetch(conn, offset, limit)
      conn.fetch((offset+1)..(offset + limit), '(RFC822)').map { |struct| struct.attr['RFC822'] }
    end
  end
end

def main
  options = { :hostname => 'imap.gmail.com' }
  optparse = OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options]"
    
    opts.on('-v', '--verbosity', 'Verbosity of debugging output') do
      $log.level -= 1
    end
    
    opts.on('-h', '--help', 'Display this message') do
      puts opts
      exit(1)
    end

    opts.on('-s HOSTNAME', '--server HOSTNAME') do |hostname|
      options[:hostname] = hostname
    end

    opts.on('-u USERNAME', '--username USERNAME') do |username|
      options[:username] = username
    end

    opts.on('-p PASSWORD', '--password PASSWORD') do |password|
      options[:password] = password
    end
  end
  optparse.parse!
  
  if ARGV.length > 3
    puts optparse
    return 1
  end

  hostname = options[:hostname] || SpamCan::Settings[:imap, :hostname]
  username = options[:username] || SpamCan::Settings[:imap, :username]
  password = options[:password] || SpamCan::Settings[:imap, :password]
  runner = SpamCan::UpdateCorpus.new(hostname, username, password)
  runner.handle_signals
  runner.run
  return 0
end

if $0 == __FILE__
  ret = main
  begin
    exit(ret)
  rescue TypeError
    exit(0)
  end
end
