#!/usr/bin/env ruby
require 'logger'
require 'optparse'
require 'rubygems'

require File.join(File.dirname(__FILE__), '../lib/spam-can')

$log = Logger.new(STDOUT)
$log.level = Logger::WARN

module SpamCan
  class ApplyFilter
    include CLIHelper
    include SpamHelper

    def run
      records = 0
      # TODO: update this
      Model::TrainingEmail.all(:type => 'testing_spam').each do |email|
        break if $should_exit

        log_announce("Starting to score email #{email.id}")
        body = email.body
        log_announce("Tokenizing email #{email.id}")
        tokens = tokenize(body)

        log_announce("Assigning probabilities to each token in #{email.id}")
        scores = {}
        tokens.each do |token|
          if pt = Model::ProbabilityTable.first(:word => BSON::Binary.new(token))
            p = pt.probability
          else
            p = 0.4
          end
          scores[token] = p
        end

        # Could be a heap, but meh.
        most_interesting = scores.sort_by { |key, value| -(0.5-value).abs }[0...15]
        log_announce("Most interesting tokens: #{most_interesting.inspect}")
        probs = most_interesting.map { |key, value| value }
        num = product(probs)
        denom2 = product(probs) { |value| 1 - value }

        prob = num / (num + denom2)

        log_announce("Probability that this email (#{email.id}) is spam: #{prob} (num: #{num} denom2: #{denom2})")

        records += 1
      end
      log_announce("Processed #{records} emails")
    end

    def product(ary, &blk)
      initial = 1
      ary.each do |value|
        value = blk.call(value) if blk
        initial *= value
      end
      initial
    end
  end
end

def main
  options = {}
  optparse = OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options]"
    
    opts.on('-v', '--verbosity', 'Verbosity of debugging output') do
      $log.level -= 1
    end
    
    opts.on('-h', '--help', 'Display this message') do
      puts opts
      exit(1)
    end

    opts.on('-r', '--refresh', 'Refresh the probability table') do
      options[:refresh] = true
    end
  end
  optparse.parse!
  
  if ARGV.length != 0
    puts optparse
    return 1
  end

  Signal.trap("INT") do
    puts "Preparing to exit..."
    $should_exit = true
  end
  Signal.trap("TERM") do
    puts "Preparing to exit..."
    $should_exit = true
  end

  runner = SpamCan::ApplyFilter.new
  runner.run
  return 0
end

if $0 == __FILE__
  ret = main
  begin
    exit(ret)
  rescue TypeError
    exit(0)
  end
end
